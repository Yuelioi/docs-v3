---
display_name: sample_light
order: 21
---
| Context(s) | [displace](../contexts/displace.html)  [fog](../contexts/fog.html)  [surface](../contexts/surface.html) |
| --- | --- |

`int  sample_light(int lightid, vector pos, vector sam, float time, vector &pos, vector &clr, float &scale, ...)`

Show/hide arguments

`lightid`

An integer identifying a light. You can get a list of light IDs for lights affecting the currently shaded surface with [getlights](getlights.html "Returns an array of light identifiers for the currently shaded surface.").

`pos`

The surface point from which lights should be sampled. Area light sources will attempt to distribute samples by solid angle from the position - that is, light geometry that is closer to the position will receive more samples.

`sam`

A vector of random values, such as those generated by [nextsample](nextsample.html). Currently only the first 2 components of `sam` are used. Different values of `sam` translate into different random positions on the geometry of the light source.

`time`

Time to shade at.

The function modifies the values of the following arguments:

Show/hide arguments

`pos`

The sampled position on the light source.

`clr`

The light color set by the light shader.

`scale`

The light average hemispherical intensity (for area lights).

Returns

A [component bitmask](bouncemask.html) indicating what types of component bounces the light affects.

Tip
If you are using [sample_light](sample_light.html "Samples a 3D position on a light source and runs the light shader at that point.") to generate light colors, for example
to reproduce the `Cl` values that would be produced by a [illuminance](illuminance.html "Loops through all light sources in the scene, calling the light shader for each light source to set the Cl and L global variables.")
loop, you will need to normalize `clr` to `scale`:

```vex
clr *= scale / luminance(clr);

```
